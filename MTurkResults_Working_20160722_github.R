#load("/Users/gregorymatthews/Dropbox/brophyTeeth/MechanicalTurkPaper/MTurk2016-11-06.RData")
library(vegan)
library(geomorph)
library(EBImage)
library(shapes)
library(devtools)
install_github("vbonhomme/Momocs")
library(Momocs)



####################################################################
##Converting the black and white shape files to .jpg, grayscale and trimming
##Note: This only needs to be run once.  
####################################################################
#Shell script
#ImageMagick
#folderGold  <-  "/Users/gregorymatthews/Dropbox/brophyTeeth/RandomTestTeeth/julietStandard/"
#Convert to .jpg
#system(paste("cd ",folderGold,'; for i in *.png ; do convert "$i" "${i%.*}.jpg" ; done',sep=" "))
#Convert to gray scale
#system(paste("cd ",folderGold,'; for i in *.jpg; do convert "$i" -colorspace Gray "$i"; done',sep=" "))
#Trim to center
#system(paste("cd ",folderGold,'; for i in *.jpg; do convert -trim "$i" "$i"; done',sep=" "))




#Reading in the file that tells us what species and tribe each tooth is
key <- read.csv("/Users/gregorymatthews/Dropbox/brophyTeeth/MechanicalTurkPaper/MTurkFile_TribeSpeciesToothKey.csv")
key <- key[key$Tribe!="",]
key$Pic.Number <- as.character(key$Pic.Number)
key$Tribe <- as.character(key$Tribe)
key$Genus.Species <- as.character(key$Genus.Species)

####################################################################
##Read in files traced by the expert (i.e. Dr. Juliet Brophy)
####################################################################
#Get the file names of Juliet's b/w images.
#98 total teeth
goldFiles  <-  list.files("/Users/gregorymatthews/Dropbox/brophyTeeth/RandomTestTeeth/julietStandard/")
goldFiles  <-  goldFiles[grep("jpg",goldFiles)]


datMTurkList  <-  list()
datGoldList  <-  list()
efList  <-  list()
distList  <-  list()
ptsListMean  <-  ptsListMeanJuliet <- list()
for (g in c(1:length(goldFiles))){print(g)
  #Read in the files from Juliet
  imgID  <-  goldFiles[g]
  
  #Contains the images traced by the expert
  imgsGold  <-  import_jpg(paste("/Users/gregorymatthews/Dropbox/brophyTeeth/RandomTestTeeth/julietStandard/",imgID,sep=""))
  
  #Tribe and Species info
  id  <-  strsplit(imgID,"[.]")[[1]][1]
  num  <-  substring(id,5,nchar(id))
  
  
  ####################################################################
  ##MTurk Files 
  ####################################################################
  folderTemp  <-  paste("/Users/gregorymatthews/Dropbox/brophyTeeth/MechanicalTurk-May-110imagescopy/",id,sep="")
  fff <- list.files(folderTemp,full=TRUE)
  
  fff  <-  fff[grep("jpe*g",fff)]
  imgsMTurk <- import_jpg(fff) #Contains up to 3 images done by MTruk workers
  
  #Do EFA to line the teeth up.  We will use the points generated by EFA at landmarks.
  #The first several (usually three) elements of efList are the MTurk workers and the last (usually fourth) is Juliet.
  efList <- list()
  #Do EFA
  for (i in 1:length(imgsMTurk)){
   ef  <-  efourier(imgsMTurk[[i]],nb.h=15,norm=FALSE)
   ef$ao  <-  0;ef$co  <-  0
   efList[[i]] <- ef
  }
  ef  <-  efourier(imgsGold[[1]],nb.h=15,norm=FALSE)
  ef$ao  <-  0;ef$co  <-  0
  efList[[4]]  <-  ef
  
  #Store all of the tracing for one tooth in the same object.  
  if (length(imgsMTurk)==3){imgs  <-  list(imgsMTurk[[1]],imgsMTurk[[2]],imgsMTurk[[3]],imgsGold[[1]])}
  if (length(imgsMTurk)==2){imgs  <-  list(imgsMTurk[[1]],imgsMTurk[[2]],imgsGold[[1]])}
  
  #Define landmarks
  outCoo  <-  Out(imgs)
  #Do EFA
  test  <-  efourier(outCoo,nb.h=30,norm=FALSE)
  
  
  
  numPoints <- 150
  ptsList <- list()
  for (j in 1:dim(test$coe)[1]){
    a  <-  grep("A",colnames(test$coe))
    b  <-  grep("B",colnames(test$coe))
    c  <-  grep("C",colnames(test$coe))
    d  <-  grep("D",colnames(test$coe))
    ptsList[[j]] <- efourier_shape(test$coe[j,a],test$coe[j,b],test$coe[j,c],test$coe[j,d],plot=FALSE,nb.pts=numPoints)
  }
  

  distGoldVec <- rep(NA,(length(ptsList)-1))
  col  <-  c("red","blue","gold","black")
  
  #Uncomment for plots
  # postscript(paste0("/Users/gregorymatthews/Dropbox/brophyTeeth/MechanicalTurkPaper/mturkResults/MTurkComparisonPlot_",id,".eps"))
  # plot(ptsList[[length(ptsList)]],type="l",lwd=10,xlim=c(-500,500),ylim=c(-500,500),main=id)
  # for (t in 1:(length(ptsList)-1)){
  #   points(ptsList[[t]],type="l",col=col[t],lwd=2)
  #   distGoldVec[t] <- riemdist(ptsList[[length(ptsList)]],ptsList[[t]])
  #   distGoldVec <- c(0.0302,0.052,0.058)
  #   #distGoldVec <- c(0.1516,0.0879,0.0517)
  #   text(200,400-(t-1)*50,round(distGoldVec[t],4),col=col[t])
  # }
  # dev.off()
  
  
  
  if (num%in%key$Pic.Number){
    efList[[g]] <- data.frame(id=num,who = c(rep("MTurk",dim(test)[1]-1),"Juliet"),tribe=key$Tribe[key$Pic.Number==num],toothPos=key$Tooth.position[key$Pic.Number==num],error = c(distGoldVec,0),test$coe)
  }
  
  distList[[id]] <- distGoldVec
  
  
  #Here we remove teeth that are too far away from the average tracing.  
  #The cutoff here was chosen manually via visual inspection of the tracings.  
  cutoff  <-  0.2 
  for (ttt in 1:length(distGoldVec)){
    if (distGoldVec[ttt]>cutoff){ptsList[[ttt]] <- NULL}
  }
  
  
  #Initialize these lists to have the same structure as ptsList
  ptsListMeanJuliet[[id]] <- ptsListMean[[id]] <- ptsList[[1]]
  
  
  all  <-  do.call(cbind,ptsList)
  #Average across ptsList
  if (dim(all)[2]>2){
    
    #Average across Expert ands MTurk Workers
    xxx <- seq(1,dim(all)[2],2)
    yyy <- seq(1,dim(all)[2],2)+1
    if (length(xxx)==1){
      ptsListMeanJuliet[[id]][,1] <- (all[,xxx])
      ptsListMeanJuliet[[id]][,2] <- (all[,yyy])
    }
    
    if (length(xxx)>1){
      ptsListMeanJuliet[[id]][,1] <- apply(all[,xxx],1,mean)
      ptsListMeanJuliet[[id]][,2] <- apply(all[,yyy],1,mean)
    }
    
    #Average across only the MTurk workers
    #The expert is the last tooth in each list and is removed from this averaging
    xxx <- seq(1,dim(all)[2]-2,2)
    yyy <- seq(1,dim(all)[2]-2,2)+1
    if (length(xxx)==1){
      ptsListMean[[id]][,1] <- (all[,xxx])
      ptsListMean[[id]][,2] <- (all[,yyy])
    }
    
    if (length(xxx)>1){
      ptsListMean[[id]][,1] <- apply(all[,xxx],1,mean)
      ptsListMean[[id]][,2] <- apply(all[,yyy],1,mean)
    }
    
  }
  
  
}


#################################################################
##Now do clasification
#################################################################

####Use efList to do classification
dat <- do.call(rbind,efList)

small <- dat[!duplicated(dat$id),]
#sum(table(small$tribe,small$toothPos))

mturk <- dat[dat$who=="MTurk",]
summary(mturk$error)

# Plots for the manuscript
# jpeg("/Users/gregorymatthews/Dropbox/brophyTeeth/errorByTribe.jpg",res=300,units="in",w=4,h=4)
# boxplot(mturk$error~mturk$tribe,ylab="Riemann Error",xlab = "Tooth Position")
# dev.off()
# 
# jpeg("/Users/gregorymatthews/Dropbox/brophyTeeth/errorByToothpos.jpg",res=300,units="in",w=4,h=4)
# boxplot(mturk$error~as.character(mturk$toothPos),ylab="Riemann Error",xlab = "Tooth Position")
# dev.off()
# 
# jpeg("/Users/gregorymatthews/Dropbox/brophyTeeth/errorHist.jpg",res=300,units="in",w=4,h=4)
# hist(mturk$error,main="",xlab= "Riemann Error")
# dev.off()


# postscript("/Users/gregorymatthews/Dropbox/brophyTeeth/MechanicalTurkPaper/errorByTribe.eps")
# boxplot(mturk$error~mturk$tribe,ylab="Riemann Error",xlab = "Tooth Position")
# dev.off()
# 
# postscript("/Users/gregorymatthews/Dropbox/brophyTeeth/MechanicalTurkPaper/errorByToothpos.eps")
# boxplot(mturk$error~as.character(mturk$toothPos),ylab="Riemann Error",xlab = "Tooth Position")
# dev.off()
# 
# postscript("/Users/gregorymatthews/Dropbox/brophyTeeth/MechanicalTurkPaper/errorHist.eps")
# hist(mturk$error,main="",xlab= "Riemann Error")
# dev.off()


##########################################################################################
##Classification using only the expert tracings
##########################################################################################
library(randomForest)
predList <- list()
set.seed(1234)

datJuliet  <-  dat[dat$who=="Juliet",]
datTemp <- datJuliet[datJuliet$toothPos=="LM2",]
datTemp$tribe <- as.factor(as.character(datTemp$tribe))

form <- as.formula(paste0("tribe~", paste(paste0("A",1:30),collapse="+"), "+",paste(paste0("B",1:30),collapse="+"), "+", paste(paste0("C",1:30),collapse="+"), "+", paste(paste0("D",1:30),collapse="+")))

for (i in 1:nrow(datTemp)){print(i)
  a <- randomForest(form,data=datTemp[-i,],ntree=1000)
  predList[[i]] <- predict(a,datTemp[i,],type="prob")
}

LOOCVjuliet  <-  cbind(datTemp[,1:5],do.call(rbind,predList))

for (i in 1:nrow(LOOCVjuliet)){
  LOOCVjuliet$prob[i]  <-  LOOCVjuliet[i,as.character(LOOCVjuliet$tribe[i])]
}

mean(-log(LOOCVjuliet$prob))

for (i in 1:nrow(datTemp)){print(i)
  a <- randomForest(form,data=datTemp[-i,],ntree=1000)
  predList[[i]] <- predict(a,datTemp[i,],type="response")
}
table(datTemp$tribe,unlist(predList))


##########################################################################################
##Classification using mean of MTurk workers tracings (removing obvious flawed tracings)
##########################################################################################
#Define landmarks
outCoo <- Out(ptsListMean)
#Do EFA
test <- efourier(outCoo,nb.h=30,norm=FALSE)
datMean  <-  data.frame(id = substring(rownames(test$coe),5,nchar(rownames(test$coe))) ,test$coe)

key$Tooth.position <- as.character(key$Tooth.position)
datMean$tribe <- NA
datMean$toothPos <- NA
for (j in 1:nrow(datMean)){
  if (as.character(datMean$id[j])%in%key$Pic.Number){
    datMean[j,c("tribe","toothPos")] = key[key$Pic.Number==as.character(datMean$id[j]),c("Tribe","Tooth.position")]
  }
}


datMean <- datMean[!is.na(datMean$id) & !is.na(datMean$toothPos),]
datTemp <- datMean[datMean$toothPos=="LM2",]
datTemp$tribe <- as.factor(as.character(datTemp$tribe))

form <- as.formula(paste0("tribe~", paste(paste0("A",1:30),collapse="+"), "+",paste(paste0("B",1:30),collapse="+"), "+", paste(paste0("C",1:30),collapse="+"), "+", paste(paste0("D",1:30),collapse="+")))
predListMean <- list()
for (i in 1:nrow(datTemp)){print(i)
  a <- randomForest(form,data=datTemp[-i,],ntree=1000)
  predListMean[[i]] <- predict(a,datTemp[i,],type="prob")
}

LOOCVMTurkMean  <-  cbind(datTemp[,c("id","tribe","toothPos")],do.call(rbind,predListMean))

for (i in 1:nrow(LOOCVMTurkMean)){
  LOOCVMTurkMean$prob[i]  <-  LOOCVMTurkMean[i,as.character(LOOCVMTurkMean$tribe[i])]
}

#Log Loss
mean(-log(LOOCVMTurkMean$prob))


for (i in 1:nrow(datTemp)){print(i)
  a <- randomForest(form,data=datTemp[-i,])
  predListMean[[i]] <- predict(a,datTemp[i,],type="response")
}
table(datTemp$tribe,unlist(predListMean))


##########################################################################################
##Classification using average of MTurk workers AND the expert tracings
##########################################################################################
#Define landmarks
outCoo <- Out(ptsListMeanJuliet)
#Do EFA
test <- efourier(outCoo,nb.h=30,norm=FALSE)
datMean  <-  data.frame(id = substring(rownames(test$coe),5,nchar(rownames(test$coe))) ,test$coe)



key$Tooth.position <- as.character(key$Tooth.position)
datMean$tribe <- NA
datMean$toothPos <- NA
for (j in 1:nrow(datMean)){
  if (as.character(datMean$id[j])%in%key$Pic.Number){
    datMean[j,c("tribe","toothPos")] = key[key$Pic.Number==as.character(datMean$id[j]),c("Tribe","Tooth.position")]
  }
}


datMean <- datMean[!is.na(datMean$id) & !is.na(datMean$toothPos),]
datTemp <- datMean[datMean$toothPos=="LM2",]
datTemp$tribe <- as.factor(as.character(datTemp$tribe))

form <- as.formula(paste0("tribe~", paste(paste0("A",1:30),collapse="+"), "+",paste(paste0("B",1:30),collapse="+"), "+", paste(paste0("C",1:30),collapse="+"), "+", paste(paste0("D",1:30),collapse="+")))
predListMeanJuliet <- list()
for (i in 1:nrow(datTemp)){print(i)
  a <- randomForest(form,data=datTemp[-i,])
  predListMeanJuliet[[i]] <- predict(a,datTemp[i,],type="prob")
}

LOOCVMTurkMeanJuliet  <-  cbind(datTemp[,c("id","tribe","toothPos")],do.call(rbind,predListMeanJuliet))

for (i in 1:nrow(LOOCVMTurkMeanJuliet)){
  LOOCVMTurkMeanJuliet$prob[i]  <-  LOOCVMTurkMeanJuliet[i,as.character(LOOCVMTurkMeanJuliet$tribe[i])]
}

mean(-log(LOOCVMTurkMeanJuliet$prob))


for (i in 1:nrow(datTemp)){print(i)
  a <- randomForest(form,data=datTemp[-i,],ntree=1000)
  predListMeanJuliet[[i]] <- predict(a,datTemp[i,],type="response")
}
table(datTemp$tribe,unlist(predListMeanJuliet))









##########################################################################################
##Classification using one randomly chosen Mturk worker per tooth.  
##########################################################################################
#Mechanical Turk LOOCV
set.seed(1234)
llListMTurk <- list()
for (m in 1:500){print(m)
  datMTurk  <-  dat[dat$who=="MTurk",]
  datTemp <- datMTurk[datMTurk$toothPos=="LM2",]
  datTemp$tribe <- as.factor(as.character(datTemp$tribe))
  #remove obvious errors
  
  
  datTemp <- datTemp[datTemp$error<0.2,] 
  idsVec <- unique(as.character(datTemp$id))
  form <- as.formula(paste0("tribe~", paste(paste0("A",1:30),collapse="+"), "+",paste(paste0("B",1:30),collapse="+"), "+", paste(paste0("C",1:30),collapse="+"), "+", paste(paste0("D",1:30),collapse="+")))
  
  #set.seed(12345)
  datTemp$U  <-  runif(nrow(datTemp),0,1)
  datTemp  <-  datTemp[order(datTemp$U),]
  datTemp  <-  datTemp[!duplicated(as.character(datTemp$id)),]
  
  
  
  ########################################################
  ##Compare results for different scenarios
  ########################################################
  predListMTurk <- list()
  for (i in idsVec){
    a <- randomForest(form,data=datTemp[datTemp$id!= i,])
    predListMTurk[[i]] <- predict(a,datTemp[datTemp$id== i,],type="prob")
  }
  
  
  LOOCVMTurk  <-  cbind(datTemp[,1:5],do.call(rbind,predListMTurk))
  
  for (i in 1:nrow(LOOCVMTurk)){print(i)
    LOOCVMTurk$prob[i]  <-  LOOCVMTurk[i,as.character(LOOCVMTurk$tribe[i])]
  }
  
  llListMTurk[[m]] <- mean(-log(LOOCVMTurk$prob))
}

for (i in 1:nrow(LOOCVjuliet)){
  LOOCVjuliet$prob[i]  <-  LOOCVjuliet[i,as.character(LOOCVjuliet$tribe[i])]
}

mean(-log(LOOCVjuliet$prob))

for (i in 1:nrow(LOOCVMTurk)){print(i)
  LOOCVMTurk$prob[i]  <-  LOOCVMTurk[i,as.character(LOOCVMTurk$tribe[i])]
}

mean(-log(LOOCVMTurk$prob))



# Histogram for manuscript
# 
# postscript("/Users/gregorymatthews/Dropbox/brophyTeeth/MechanicalTurkPaper/resultsHistogramLOOCV.eps")
# hist(unlist(llListMTurk),main="Distribution of Log-Loss Scores",xlab="log-loss",xlim=c(0.5,2))
# abline(v=mean(-log(LOOCVjuliet$prob)),lty=1)
# abline(v=mean(-log(LOOCVMTurkMean$prob)),lty=2)
# abline(v=mean(-log(LOOCVMTurkMeanJuliet$prob)),lty=3)
# legend(1.5,80,c("Expert","Mean of MTurk","Mean of MTurk\n and Expert"),lty=c(1,2,3))
# dev.off()
# 
# save.image("/Users/gregorymatthews/Dropbox/brophyTeeth/MechanicalTurkPaper/MTurk2016-11-06.RData")




plot(LOOCVjuliet$prob,LOOCVMTurkMean$prob,main="Probabilites of true class: MTurk vs Expert",xlab="Expert",ylab="Mean MTurk")
abline(a=0,b=1)

